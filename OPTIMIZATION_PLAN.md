# GCR代理服务优化方案

## 当前问题分析

### 性能瓶颈
1. **任务失败率高**：22个任务中10个失败
2. **超时问题**：API调用超时（3分钟限制）
3. **回调延迟**：并发回调时存在10-15秒延迟
4. **资源不足**：CPU使用率100%，内存压力大

### 根本原因
1. 云雾API响应慢（2-3分钟生成图片）
2. 并发任务时容器资源不足
3. 回调机制增加复杂性和故障点

## 已实施优化

### 1. 超时时间调整
- ✅ API调用超时：3分钟 → 4分钟
- ✅ 给图片生成更多时间

### 2. 容器配置优化
- ✅ CPU：1 vCPU（保持）
- ✅ 内存：1GB → 512MB（降低成本）
- ✅ 并发数：每实例1个请求
- ✅ 最大实例：100个

### 3. 代码优化
- ✅ 使用fetch替代https.request
- ✅ Workers端异步处理回调
- ✅ API域名切换到yunwu.zeabur.app

## 后续优化方案

### 方案一：改为轮询模式（推荐）

#### 架构变更
```
当前：Workers → GCR → 云雾API → GCR回调 → Workers
改为：Workers → GCR → 云雾API → GCR存储
      Workers轮询 → GCR查询接口 → 获取结果
```

#### 实现步骤
1. **GCR端改动（20行）**
   - 注释回调逻辑
   - 保留结果存储

2. **Workers端改动（40行）**
   - 删除callbackUrl
   - 添加轮询函数
   - 5秒查询一次，最多5分钟

#### 优势
- 简化架构，去除回调复杂性
- 避免网络回调失败
- 易于调试和监控
- 改动量小（60行代码）

#### 劣势
- 轮询有5秒延迟
- 增加请求次数

### 方案二：使用Cloud Tasks（长期）

#### 架构
```
Workers → GCR → Cloud Tasks队列
                     ↓
                Worker处理 → 云雾API
                     ↓
                 存储结果
```

#### 优势
- 自动重试
- 速率控制
- 高可靠性
- 解耦架构

### 方案三：Cloud Storage存储

#### 实现
- GCR完成后存储到Cloud Storage
- Workers通过公开URL直接读取
- 无需经过GCR查询

## 性能对比

| 指标 | 当前回调方案 | 轮询方案 | Cloud Tasks |
|-----|------------|---------|------------|
| 复杂度 | 高 | 低 | 中 |
| 可靠性 | 中 | 高 | 很高 |
| 延迟 | 1-15秒 | 5-10秒 | 1-5秒 |
| 改动量 | - | 60行 | 200行 |
| 成本 | 低 | 低 | 中 |

## 建议实施顺序

1. **立即**：实施轮询方案（1小时完成）
2. **本周**：监控性能，收集数据
3. **下周**：如需要，实施Cloud Tasks

## 监控指标

- 任务成功率（目标：>95%）
- 平均完成时间（目标：<3分钟）
- 超时率（目标：<5%）
- 容器CPU使用率（目标：<80%）

## 回滚方案

如轮询方案有问题，可立即回滚：
1. 恢复回调代码
2. 重新部署
3. 15分钟内完成

## 成本分析

### 当前月成本
- Cloud Run：约$20（100个实例）
- 网络流量：约$5

### 优化后预期
- Cloud Run：约$15（512MB内存）
- 网络流量：约$7（轮询增加）
- **总计节省：约$3/月**